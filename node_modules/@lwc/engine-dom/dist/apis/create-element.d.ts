import type { LightningElement } from '@lwc/engine-core';
/**
 * Gets the public properties of a component class. If the `__lwc_public_property_types__` property
 * is defined, it will be used as the source of truth for the property types. Otherwise, all of the
 * properties defined on the component class are used, excluding those inherited from `LightningElement`.
 *
 * IMPORTANT: If the fallback is used, then _all_ component properties are returned, rather than
 * just the public properties.
 */
type ComponentClassProperties<T> = T extends {
    readonly __lwc_public_property_types__?: infer Props extends object;
} ? Props : Omit<T, keyof LightningElement>;
/**
 * The custom element returned when calling {@linkcode createElement} with the given component
 * constructor.
 *
 * NOTE: By default, the returned type includes _all_ properties defined on the component class,
 * even though the runtime object only uses those decorated with `@api`. This is due to a
 * limitation of TypeScript. For example:
 *
 * ```
 * class Example extends LightningElement {
 *   @api exposed = 'hello'
 *   internal = 'secret'
 * }
 * const example = createElement('c-example', { is: Example })
 * // TypeScript thinks that `example.internal` is a string, when it's actually undefined.
 * const exposed = example.exposed // type is 'string'
 * console.log(exposed) // prints 'hello'
 * const internal = example.internal // type is 'string'
 * console.log(internal) // prints `undefined`
 * ```
 *
 * One way to avoid inferring incorrect properties, is to provide an explicit generic parameter.
 * For example:
 * ```
 * const example = createElement<{exposed: string}>('c-example', { is: Example })
 * const exposed = example.exposed // type is 'string'
 * const internal = example.internal // Now a type error! ✅
 * ```
 *
 * Alternatively, you can define a type for property on the component, `__lwc_public_property_types__`,
 * that explicitly lists only the public properties, and the types will be inferred from that prop.
 * The property should be optional, because it does not actually exist at runtime.
 * For example:
 * ```
 * class Example extends LightningElement {
 *   @api exposed = 'hello'
 *   internal = 'secret'
 *   __lwc_public_property_types__?: { exposed: string }
 * }
 * const example = createElement('c-example', { is: Example })
 * const exposed = example.exposed // type is 'string'
 * const internal = example.internal // Now a type error! ✅
 * ```
 */
export type LightningHTMLElement<T> = HTMLElement & ComponentClassProperties<T>;
/**
 * EXPERIMENTAL: This function is almost identical to document.createElement with the slightly
 * difference that in the options, you can pass the `is` property set to a Constructor instead of
 * just a string value. The intent is to allow the creation of an element controlled by LWC without
 * having to register the element as a custom element.
 *
 * NOTE: The returned type incorrectly includes _all_ properties defined on the component class,
 * even though the runtime object only uses those decorated with `@api`. This is due to a
 * limitation of TypeScript. To avoid inferring incorrect properties, provide an explicit generic
 * parameter, e.g. `createElement<typeof LightningElement>('x-foo', { is: FooCtor })`.
 * @param sel The tagname of the element to create
 * @param options Control the behavior of the created element
 * @param options.is The LWC component that the element should be
 * @param options.mode What kind of shadow root to use
 * @returns The created HTML element
 * @throws Throws when called with invalid parameters.
 * @example
 * const el = createElement('x-foo', { is: FooCtor });
 */
export declare function createElement<Component>(sel: string, options: {
    is: LightningElement['constructor'] & {
        new (): Component;
    };
    mode?: 'open' | 'closed';
}): LightningHTMLElement<Component>;
export {};
//# sourceMappingURL=create-element.d.ts.map